const int in1= 9 ;
const int in2 = 8 ;
const int in3 = 7;
const int in4 = 6;
const int ena = 10 ;
const int enb = 5;
char readchar;


int volt=255;

void Forward() {
   analogWrite(ena,volt);
   analogWrite(enb,volt);
  digitalWrite(in1,LOW);
  digitalWrite(in2,HIGH);
  digitalWrite(in3,LOW);
  digitalWrite(in4,HIGH);
  }

void Backward()
{
    analogWrite(ena,volt);
   analogWrite(enb,volt);
  digitalWrite(in1,HIGH);
  digitalWrite(in2,LOW);
  digitalWrite(in3,HIGH);
digitalWrite(in4,LOW);
}

void Right()
{
  analogWrite(enb,volt);
  digitalWrite(in1,LOW);
  digitalWrite(in2,LOW);
  digitalWrite(in3,LOW);
  digitalWrite(in4,HIGH);
  }

void Left()
{
  analogWrite(ena,volt);
  digitalWrite(in1,LOW);
  digitalWrite(in2,HIGH);
  digitalWrite(in3,LOW);
  digitalWrite(in4,LOW);
}

void Stop()
{
  digitalWrite(in1,LOW);
  digitalWrite(in2,LOW);
  digitalWrite(in3,LOW);
  digitalWrite(in4,LOW);
}
const byte MOTOR_A =2;  

const float stepcount = 20.00;  

const float wheeldiameter = 64.00; 
 
volatile int counter_A = 0;


 void ISR_countA()  
{counter_A++;  // increment Motor A counter value
} 
 

int CMtoSteps(float cm) {
 
  int result;  
  float circumference = (wheeldiameter * 3.14) / 10; 
  float cm_step = circumference / stepcount;  
  
  float f_result = cm / cm_step;  
  result = (int) f_result; 
  
  return result;  
 Serial.println("result");
 Serial.println(result);
}


void MoveForward(int steps, int mspeed) 
{
   counter_A = 0;  
   Forward();
   
  
   while (steps > counter_A ) {
   
    if (steps > counter_A) {
    analogWrite(ena, mspeed);
    } else {
    analogWrite(ena, 0);
    }
   
   }
    
  
  analogWrite(ena, 0);
  analogWrite(enb, 0);

